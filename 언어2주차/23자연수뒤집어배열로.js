//sh
function solution(n) {
    // return.reverse().map(str => Number(str));
    return n.toString().split('').reverse().map(str => +str);
    // n.toString().split('') => [...String(n)]
    return [...String(n)].reverse().map(str => +str); 
    // str 요소를 하나씩 가져와서 처리하겠다. 그리고 새로운 배열을 반환하겠다. 
}



// 얕은복사?  // 깊은복사?
// 발생되는 이유가 되는 자료형 ??? // 객체 // 이유는? 메모리주소

// 원시형자료형 : number, 불린, 문자, und-,null, 
// 객체 : 배열, 함수, 객체 

// 인터프린터 언어로 동작할 때 
let a = 1 
let b = 1
b = 2
b = 3
let c = [1,2,3] //
c.push(4) // 
let d = c // [1,2,3,4] 
let e = [...c]
d.push(5) //d에만 푸쉬한 줄 알았는데 c까지 변해버린~

console.log(c, d, e)
  // c = [1,2,3,4.5]
  // d = [1,2,3,4,5] // 불변성 유지가 안되어서 동기화된 상태 // c => "3000" <= d // 얖은복사는 문제가 된다. 
  // e = [1,2,3,4]

//이게 깊은 복사, 얕은 복사를 꼭 이해하고 구현해야하는 이유ㅡㅡ;;  

// 식별자의 위치에서 생각하면 
// 식별자값 저장메모리 1000 = a(2000), 
// 식별자값 저장메모리 1001 = b(2000) => (2001)=> (2002) // 불변성 유지되었다. "
                        // a와 b의 식별자의 위치에서 봤을 때 값이 변경되면 참조하는 메모리의 "주소"가 변경되었잖아. 이전에잠조했었던 메모리주소는? 2000 => 다음참조는 2001 // 식별자의 위치 "2000"과 "2001" 다르죠 // 불변성이 유지되었다.(불변하다=메모리주소가) 
// 식별자값 저장메모리 1002 = c(3000) => 식별자의 위치에서 봤을 때 3000이 변경되었나요 안되었나요? 안되었죠 
                                    // 그대로 3000 인거에요. // 이전과 이후가 달라졌지마녀, 여전히 3000 // 즉 불변성이 유지되지 않았다. 
                                    // 이전 3000과 이후 3000은 값이 다른데, 똥멍청이가 똑같다...;; 그게 문제다. // 불변성이 유지되지 않았다. 
// 식별자값 저장메모리 1003 = d === c(3000) => d(3000) // 불변성 유지가 되지 않았다. // push // 3000 // 불변성 
// 식별자값 저장메모리 1004 = e(3001) // c와 d랑 다른거에요. 

////////////////////////////////////////////////////////

// 데이터값 저장메모리 2000 = 1 // 
// 데이터값 저장메모리 2001 = 2 // b가 가리키는 메모리주소값이 달라졌구나 2000과 2001 다르다는 것 // 2000과 2001 고유하다는 것 // 불변성 유지되었다.
// 데이터값 저장메모리 2002 = 3 // 
// 데이터값 저장메모리 2003 = 4
////////////////////////////////////////////////////////

// 참조공간 저장메모리 3000 = [2000~2003] 3000 이 바라보는 데이터값 저장메모리가 변경되었지 
// 참조공간 저장메모리 3001 = [2000~2003] 
////////////////////////////////////////////////////////